import { readdir, readFile, watch, writeFile } from 'node:fs/promises';
import { EOL } from "node:os";
import { basename, dirname, extname, join, relative } from 'node:path';
import { join as posixJoin, normalize as posixNormalize } from 'node:path/posix';

const autoGeneratedFileWarning =
  '// ************** This file was automatically generated. DO NOT MODIFY ************************';

const packageNameTag = "'" + basename(import.meta.dirname) + "': ";
const projectPath = 'esm';

const capitalizeFirstLetter = (s:string):string => s.charAt(0).toUpperCase() + s.slice(1);

const action = async () => {
  console.log(packageNameTag + "automatic 'index.ts' generation");
  const indexPath = join(projectPath, 'index.ts');

  let noIndex = false;
  let indexContent = '';
  try {
    /* eslint-disable-next-line functional/no-expression-statements */
    indexContent = await readFile(indexPath, 'utf8');
    /* eslint-disable-next-line functional/no-expression-statements */
    noIndex = false;
  } catch (e:unknown) {
    if (typeof e === 'object' && e !== null && 'code' in e && e['code'] === 'ENOENT')
      /* eslint-disable-next-line functional/no-expression-statements */
      noIndex = true;
    else throw e;
  }
  if (noIndex || indexContent.startsWith(autoGeneratedFileWarning)) {
    const projectFiles = (
      await readdir(projectPath, {
        recursive: true,
        withFileTypes: true,
      })
    )
      .map(({ name, parentPath }) => {
        const extension = extname(name);
        const bareName = name.substring(0, name.length - extension.length);
        return {
          name,
          bareName,
          capitalizedBareName: capitalizeFirstLetter(bareName),
          parentPath,
          relativePath: posixNormalize(relative(parentPath, projectPath)),
          extension,
        };
      })
      .filter(
        ({ name, extension, relativePath }) =>
          [".ts",".mts",".cts",".js",".mjs",".cjs"].includes(extension)
          && !dirname(relativePath).startsWith('internal')
          && name !== 'index.ts',
      );

    /* eslint-disable-next-line functional/no-expression-statements */
    await writeFile(
      indexPath,
      autoGeneratedFileWarning
        + EOL
        + projectFiles
          // join removes upfront './' which typescript requires
          .map(
            ({ bareName, capitalizedBareName, relativePath }) =>
              'export * as TE'
              + capitalizedBareName
              + " from './"
              + posixJoin(relativePath, bareName)
              + ".js';",
          )
          .join(EOL),
    );
  } else
    throw new Error(
      packageNameTag
        + "could not autogenerate 'index.ts' because the file already exists and does not start with predefined warning comment",
    );
};

const command = process.argv[2];
if (command === 'run')
  /* eslint-disable-next-line functional/no-expression-statements */
  await action();
else if (command === 'watch') {
  let lastEventTime = Date.now();
  const watcher = watch(projectPath, { recursive: true });
  for await (const event of watcher) {
    const currentEventTime = Date.now();
    // Avoid too many events. It's not that bad if we miss an event since we regenerate the whole file each time
    if (currentEventTime - lastEventTime > 500) {
      const changeFilename = event.filename;

      if (changeFilename === null)
        throw new Error(
          packageNameTag + 'Watch command does not include filename on this platform',
        );
      if (changeFilename !== 'index.ts' && [".ts",".mts",".cts",".js",".mjs",".cjs"].includes(extname(changeFilename))) {
        /* eslint-disable-next-line functional/no-expression-statements */
        await action();
      }
    }
    /* eslint-disable-next-line functional/no-expression-statements */
    lastEventTime = currentEventTime;
  }
} else
  throw new Error(
    packageNameTag + "Expected argument 'run' or 'watch'. Actual: '" + command + "'",
  );